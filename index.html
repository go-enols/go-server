<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è°ƒåº¦å™¨ç®¡ç†ç•Œé¢</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }
        .stat-item {
            text-align: center;
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }
        .stat-label {
            color: #6c757d;
            margin-top: 5px;
        }
        .content {
            padding: 30px;
        }
        .section {
            margin-bottom: 40px;
        }
        .section h2 {
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .worker-card {
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .worker-header {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
        }
        .worker-id {
            font-weight: bold;
            color: #495057;
        }
        .worker-status {
            float: right;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            background: #28a745;
            color: white;
        }
        .methods-list {
            padding: 20px;
        }
        .method-item {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
        }
        .method-name {
            font-weight: bold;
            color: #495057;
            margin-bottom: 8px;
        }
        .method-docs {
            color: #6c757d;
            font-size: 0.9em;
            line-height: 1.4;
        }
        .refresh-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-bottom: 20px;
        }
        .refresh-btn:hover {
            background: #5a6fd8;
        }
        .no-data {
            text-align: center;
            color: #6c757d;
            padding: 40px;
            font-style: italic;
        }
        .debug-section {
            background: #fff;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .debug-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .form-group label {
            font-weight: bold;
            color: #495057;
        }
        .form-group select,
        .form-group textarea,
        .form-group input {
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .form-group textarea {
            min-height: 100px;
            font-family: 'Courier New', monospace;
        }
        .execute-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
        }
        .execute-btn:hover {
            background: #218838;
        }
        .execute-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .result-area {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .result-success {
            border-left: 4px solid #28a745;
            background: #d4edda;
        }
        .result-error {
            border-left: 4px solid #dc3545;
            background: #f8d7da;
        }
        .method-debug-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 10px;
        }
        .method-debug-btn:hover {
            background: #138496;
        }
        .method-toggle-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.7em;
            margin-left: 10px;
        }
        .method-toggle-btn:hover {
            background: #5a6268;
        }
        .method-docs {
            color: #6c757d;
            font-size: 0.9em;
            line-height: 1.4;
            display: none;
            margin-top: 8px;
        }
        .method-docs.expanded {
            display: block;
        }
        
        /* é€‰é¡¹å¡æ ·å¼ */
        .tab-nav {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .tab-btn {
            background: none;
            border: none;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 1em;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .tab-btn:hover {
            color: #495057;
            background: #f8f9fa;
        }
        .tab-btn.active {
            color: #007bff;
            border-bottom-color: #007bff;
            background: #f8f9fa;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .form-help {
            display: block;
            margin-top: 5px;
            color: #6c757d;
            font-size: 0.85em;
        }
        .json-input-container {
            position: relative;
        }
        .json-tools {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .json-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        .json-btn:hover {
            background: #5a6268;
        }
        .json-preview {
            margin-top: 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: #f8f9fa;
            max-height: 300px;
            overflow-y: auto;
        }
        .json-preview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        .json-preview-table th,
        .json-preview-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        .json-preview-table th {
            background: #e9ecef;
            font-weight: bold;
            position: sticky;
            top: 0;
        }
        .json-preview-table tr:hover {
            background: #f1f3f4;
        }
        .json-key {
            font-family: 'Courier New', monospace;
            color: #0066cc;
            font-weight: bold;
        }
        .json-value {
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }
        .json-type {
            font-size: 11px;
            color: #6c757d;
            font-style: italic;
        }
        .json-error {
            color: #dc3545;
            padding: 10px;
            font-family: 'Courier New', monospace;
        }
        
        /* ä»»åŠ¡è¡¨æ ¼æ ·å¼ */
        .tasks-table-container {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }
        
        .tasks-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
        }
        
        .tasks-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            padding: 12px;
            text-align: left;
            border-bottom: 2px solid #dee2e6;
        }
        
        .tasks-table td {
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
            vertical-align: top;
        }
        
        .tasks-table tbody tr:hover {
            background-color: #f8f9fa;
        }
        
        .task-method {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            color: #007bff;
            background-color: #e7f3ff;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .task-params {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #495057;
            background-color: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            max-height: 100px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .task-actions {
            display: flex;
            gap: 8px;
        }
        
        .task-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        
        .task-btn.edit {
            background-color: #ffc107;
            color: #212529;
        }
        
        .task-btn.edit:hover {
            background-color: #e0a800;
        }
        
        .task-btn.delete {
            background-color: #dc3545;
            color: white;
        }
        
        .task-btn.delete:hover {
            background-color: #c82333;
        }
        
        /* å¼¹æ¡†æ ·å¼ */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: white;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
        }
        
        .modal-header h3 {
            margin: 0;
            color: #495057;
        }
        
        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #aaa;
            transition: color 0.2s;
        }
        
        .close:hover {
            color: #000;
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 20px;
            border-top: 1px solid #dee2e6;
            background-color: #f8f9fa;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #0056b3;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #545b62;
        }
        
        #taskMethodSelect {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        
        /* å¯¼å‡ºæŒ‰é’®æ ·å¼ */
        .export-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .export-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .export-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }
        
        .export-btn:active {
            transform: translateY(0);
        }
        
        .retry-btn {
            background: #fd7e14 !important;
        }
        
        .retry-btn:hover {
            background: #e8681a !important;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ è°ƒåº¦å™¨ç®¡ç†ç•Œé¢</h1>
            <p>å®æ—¶ç›‘æ§WorkerçŠ¶æ€å’Œæ³¨å†Œæ–¹æ³•</p>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-number" id="workerCount">0</div>
                <div class="stat-label">åœ¨çº¿Worker</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="methodCount">0</div>
                <div class="stat-label">æ³¨å†Œæ–¹æ³•</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="taskCount">0</div>
                <div class="stat-label">ä»»åŠ¡æ€»æ•°</div>
            </div>
        </div>
        
        <div class="content">
            <button class="refresh-btn" onclick="loadData()">ğŸ”„ åˆ·æ–°æ•°æ®</button>
            
            <div class="section">
                <h2>ğŸ“‹ Workeråˆ—è¡¨å’Œæ³¨å†Œæ–¹æ³•</h2>
                <div id="workersContainer">
                </div>
            </div>
            
            <div class="debug-section">
                <h2>ğŸ”§ æ–¹æ³•è°ƒè¯•å·¥å…·</h2>
                
                <!-- é€‰é¡¹å¡å¯¼èˆª -->
                <div class="tab-nav">
                    <button class="tab-btn active" onclick="switchTab('debug')">ğŸ› è°ƒè¯•æ¨¡å¼</button>
                    <button class="tab-btn" onclick="switchTab('batch')">ğŸš€ æ‰¹é‡è¿è¡Œ</button>
                    <button class="tab-btn" onclick="switchTab('multiBatch')">ğŸ¯ å¤šæ–¹æ³•æ‰¹é‡è¿è¡Œ</button>
                </div>
                
                <!-- è°ƒè¯•æ¨¡å¼é€‰é¡¹å¡ -->
                <div id="debugTab" class="tab-content active">
                    <div class="debug-form">
                        <div class="form-group">
                            <label for="methodSelect">é€‰æ‹©æ–¹æ³•:</label>
                            <select id="methodSelect">
                                <option value="">è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–¹æ³•</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="paramsInput">å‚æ•°:</label>
                            <div class="json-input-container">
                                <textarea id="paramsInput" placeholder='{"key": "value"}' oninput="autoFormatJSON('paramsInput')" onblur="autoFormatJSON('paramsInput')"></textarea>
                                <div class="json-tools">
                                    <button type="button" class="json-btn" onclick="toggleJSONPreview('paramsInput', 'paramsPreview')">ğŸ‘ï¸ é¢„è§ˆ</button>
                                </div>
                            </div>
                            <div id="paramsPreview" class="json-preview" style="display: none;"></div>
                        </div>
                        <div class="form-group">
                            <label for="timeoutInput">è¶…æ—¶æ—¶é—´ (ç§’):</label>
                            <input type="number" id="timeoutInput" value="30" min="1" max="300">
                        </div>
                        <button class="execute-btn" onclick="executeMethod()" id="executeBtn">ğŸš€ æ‰§è¡Œæ–¹æ³•</button>
                        <div id="resultArea" class="result-area" style="display: none;"></div>
                        <div id="debugExportButtons" class="export-buttons" style="display: none;">
                            <button class="export-btn" onclick="exportDebugResult('success')">ğŸ“¥ å¯¼å‡ºæˆåŠŸ</button>
                            <button class="export-btn" onclick="exportDebugResult('failed')">ğŸ“¥ å¯¼å‡ºå¤±è´¥</button>
                            <button class="export-btn" onclick="exportDebugResult('all')">ğŸ“¥ å¯¼å‡ºå…¨éƒ¨</button>
                            <button class="export-btn retry-btn" onclick="retryFailedDebugTasks()">ğŸ”„ é‡æ–°è¿è¡Œå¤±è´¥</button>
                        </div>
                    </div>
                </div>
                
                <!-- æ‰¹é‡è¿è¡Œé€‰é¡¹å¡ -->
                <div id="batchTab" class="tab-content">
                    <div class="debug-form">
                        <div class="form-group">
                            <label for="batchMethodSelect">é€‰æ‹©æ–¹æ³•:</label>
                            <select id="batchMethodSelect">
                                <option value="">è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–¹æ³•</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="batchParamsInput">å‚æ•°åˆ—è¡¨ (JSONæ•°ç»„æ ¼å¼):</label>
                            <div class="json-input-container">
                                <textarea id="batchParamsInput" placeholder='[{"key": "value1"}, {"key": "value2"}, {"key": "value3"}]' oninput="autoFormatJSON('batchParamsInput')" onblur="autoFormatJSON('batchParamsInput')"></textarea>
                                <div class="json-tools">
                                    <button type="button" class="json-btn" onclick="toggleJSONPreview('batchParamsInput', 'batchParamsPreview')">ğŸ‘ï¸ é¢„è§ˆ</button>
                                </div>
                            </div>
                            <div id="batchParamsPreview" class="json-preview" style="display: none;"></div>
                            <small class="form-help">æ¯ä¸ªæ•°ç»„å…ƒç´ ä»£è¡¨ä¸€æ¬¡æ–¹æ³•è°ƒç”¨çš„å‚æ•°</small>
                        </div>
                        <div class="form-group">
                            <label for="batchTimeoutInput">å•æ¬¡è¶…æ—¶æ—¶é—´ (ç§’):</label>
                            <input type="number" id="batchTimeoutInput" value="30" min="1" max="300">
                        </div>
                        <div class="form-group">
                            <label for="concurrencyInput">å¹¶å‘æ•°:</label>
                            <input type="number" id="concurrencyInput" value="1" min="1" max="10">
                            <small class="form-help">åŒæ—¶æ‰§è¡Œçš„ä»»åŠ¡æ•°é‡</small>
                        </div>
                        <div class="form-group">
                            <label for="intervalInput">æ‰§è¡Œé—´éš” (æ¯«ç§’):</label>
                            <input type="text" id="intervalInput" placeholder="ä¾‹å¦‚: 1000 æˆ– 500-2000" value="0">
                            <small class="form-help">å›ºå®šé—´éš”(å¦‚1000)æˆ–éšæœºèŒƒå›´(å¦‚500-2000)ï¼Œ0è¡¨ç¤ºæ— é—´éš”</small>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="randomOrderInput"> éšæœºè¿è¡Œé¡ºåº
                            </label>
                            <small class="form-help">å‹¾é€‰åå°†éšæœºé€‰æ‹©å‚æ•°æ‰§è¡Œï¼Œä¸é‡å¤ç›´åˆ°å…¨éƒ¨å®Œæˆ</small>
                        </div>
                        <button class="execute-btn" onclick="executeBatchMethod()" id="batchExecuteBtn">ğŸš€ æ‰¹é‡æ‰§è¡Œ</button>
                        <div id="batchResultArea" class="result-area" style="display: none;"></div>
                        <div id="batchExportButtons" class="export-buttons" style="display: none;">
                            <button class="export-btn" onclick="exportBatchResult('success')">ğŸ“¥ å¯¼å‡ºæˆåŠŸ</button>
                            <button class="export-btn" onclick="exportBatchResult('failed')">ğŸ“¥ å¯¼å‡ºå¤±è´¥</button>
                            <button class="export-btn" onclick="exportBatchResult('all')">ğŸ“¥ å¯¼å‡ºå…¨éƒ¨</button>
                            <button class="export-btn retry-btn" onclick="retryFailedBatchTasks()">ğŸ”„ é‡æ–°è¿è¡Œå¤±è´¥</button>
                        </div>
                    </div>
                </div>
                
                <!-- å¤šæ–¹æ³•æ‰¹é‡è¿è¡Œé€‰é¡¹å¡ -->
                <div id="multiBatchTab" class="tab-content">
                    <div class="debug-form">
                        <div class="form-group">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <label>ä»»åŠ¡é…ç½®:</label>
                                <button type="button" class="json-btn" onclick="showAddTaskModal()">â• æ·»åŠ ä»»åŠ¡</button>
                            </div>
                            <div id="multiBatchTasksTable" class="tasks-table-container">
                                <table class="tasks-table">
                                    <thead>
                                        <tr>
                                            <th style="width: 60px;">#</th>
                                            <th style="width: 150px;">æ–¹æ³•</th>
                                            <th>å‚æ•°</th>
                                            <th style="width: 120px;">æ“ä½œ</th>
                                        </tr>
                                    </thead>
                                    <tbody id="multiBatchTasksTableBody">
                                        <tr class="no-tasks-row">
                                            <td colspan="4" style="text-align: center; color: #6c757d; font-style: italic; padding: 20px;">æš‚æ— ä»»åŠ¡ï¼Œç‚¹å‡»"æ·»åŠ ä»»åŠ¡"å¼€å§‹é…ç½®</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                            <small class="form-help">é…ç½®å¤šä¸ªä¸åŒæ–¹æ³•çš„æ‰¹é‡æ‰§è¡Œä»»åŠ¡</small>
                        </div>
                        <div class="form-group">
                            <label for="multiBatchTimeoutInput">å•æ¬¡è¶…æ—¶æ—¶é—´ (ç§’):</label>
                            <input type="number" id="multiBatchTimeoutInput" value="30" min="1" max="300">
                        </div>
                        <div class="form-group">
                            <label for="multiBatchConcurrencyInput">å¹¶å‘æ•°:</label>
                            <input type="number" id="multiBatchConcurrencyInput" value="1" min="1" max="10">
                            <small class="form-help">åŒæ—¶æ‰§è¡Œçš„ä»»åŠ¡æ•°é‡</small>
                        </div>
                        <div class="form-group">
                            <label for="multiBatchIntervalInput">æ‰§è¡Œé—´éš” (æ¯«ç§’):</label>
                            <input type="text" id="multiBatchIntervalInput" placeholder="ä¾‹å¦‚: 1000 æˆ– 500-2000" value="0">
                            <small class="form-help">å›ºå®šé—´éš”(å¦‚1000)æˆ–éšæœºèŒƒå›´(å¦‚500-2000)ï¼Œ0è¡¨ç¤ºæ— é—´éš”</small>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="multiBatchRandomOrderInput"> éšæœºè¿è¡Œé¡ºåº
                            </label>
                            <small class="form-help">å‹¾é€‰åå°†éšæœºé€‰æ‹©ä»»åŠ¡æ‰§è¡Œï¼Œä¸é‡å¤ç›´åˆ°å…¨éƒ¨å®Œæˆ</small>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="multiBatchGroupByMethodInput"> æŒ‰æ–¹æ³•åˆ†ç»„æ˜¾ç¤ºç»“æœ
                            </label>
                            <small class="form-help">å‹¾é€‰åç»“æœå°†æŒ‰æ–¹æ³•ååˆ†ç»„æ˜¾ç¤ºï¼Œä¾¿äºæŸ¥çœ‹</small>
                        </div>
                        <button class="execute-btn" onclick="executeMultiBatchMethod()" id="multiBatchExecuteBtn">ğŸ¯ å¤šæ–¹æ³•æ‰¹é‡æ‰§è¡Œ</button>
                        <div id="multiBatchResultArea" class="result-area" style="display: none;"></div>
                        <div id="multiBatchExportButtons" class="export-buttons" style="display: none;">
                            <button class="export-btn" onclick="exportMultiBatchResult('success')">ğŸ“¥ å¯¼å‡ºæˆåŠŸ</button>
                            <button class="export-btn" onclick="exportMultiBatchResult('failed')">ğŸ“¥ å¯¼å‡ºå¤±è´¥</button>
                            <button class="export-btn" onclick="exportMultiBatchResult('all')">ğŸ“¥ å¯¼å‡ºå…¨éƒ¨</button>
                            <button class="export-btn retry-btn" onclick="retryFailedMultiBatchTasks()">ğŸ”„ é‡æ–°è¿è¡Œå¤±è´¥</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- æ·»åŠ ä»»åŠ¡å¼¹æ¡† -->
    <div id="addTaskModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">æ·»åŠ ä»»åŠ¡</h3>
                <span class="close" onclick="closeAddTaskModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="taskMethodSelect">é€‰æ‹©æ–¹æ³•:</label>
                    <select id="taskMethodSelect" onchange="updateTaskParamsInput()">
                        <option value="">è¯·é€‰æ‹©æ–¹æ³•</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="taskParamsInput">å‚æ•°åˆ—è¡¨ (JSONæ•°ç»„æ ¼å¼):</label>
                    <div class="json-input-container">
                        <textarea id="taskParamsInput" placeholder='[{"key": "value1"}, {"key": "value2"}, {"key": "value3"}]' rows="6"></textarea>
                        <div class="json-tools">
                            <button type="button" class="json-btn" onclick="formatTaskParams()">ğŸ”§ æ ¼å¼åŒ–</button>
                            <button type="button" class="json-btn" onclick="toggleTaskParamsPreview()">ğŸ‘ï¸ é¢„è§ˆ</button>
                        </div>
                    </div>
                    <div id="taskParamsPreview" class="json-preview" style="display: none;"></div>
                    <small class="form-help">æ¯ä¸ªæ•°ç»„å…ƒç´ ä»£è¡¨ä¸€æ¬¡æ–¹æ³•è°ƒç”¨çš„å‚æ•°ï¼Œæ”¯æŒå•ä¸ªæ–¹æ³•å¤šä¸ªå‚æ•°ç»„åˆ</small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="closeAddTaskModal()">å–æ¶ˆ</button>
                <button type="button" class="btn btn-primary" onclick="saveTask()" id="saveTaskBtn">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let multiBatchTasks = []; // å­˜å‚¨å¤šæ–¹æ³•æ‰¹é‡è¿è¡Œçš„ä»»åŠ¡åˆ—è¡¨
        
        function loadData() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    updateStats(data);
                    updateWorkers(data.workers);
                })
                .catch(error => {
                    console.error('Error loading data:', error);
                    document.getElementById('workersContainer').innerHTML = 
                        '<div class="no-data">âŒ åŠ è½½æ•°æ®å¤±è´¥</div>';
                });
        }

        function updateStats(data) {
            document.getElementById('workerCount').textContent = data.workers.length;
            document.getElementById('methodCount').textContent = data.totalMethods;
            document.getElementById('taskCount').textContent = data.totalTasks;
        }

        function updateWorkers(workers) {
            const container = document.getElementById('workersContainer');
            
            if (workers.length === 0) {
                container.innerHTML = '<div class="no-data">ğŸ” æš‚æ— Workerè¿æ¥</div>';
                updateMethodSelect([]);
                return;
            }
            
            // æ”¶é›†æ‰€æœ‰å¯ç”¨çš„æ–¹æ³•
            let allMethods = [];
            workers.forEach(function(worker) {
                worker.methods.forEach(function(method) {
                    if (!allMethods.find(m => m.name === method.name)) {
                        allMethods.push(method);
                    }
                });
            });
            updateMethodSelect(allMethods);

            // è·å–ç°æœ‰çš„workerå¡ç‰‡
            const existingCards = container.querySelectorAll('.worker-card');
            const existingWorkerIds = Array.from(existingCards).map(card => {
                const workerIdSpan = card.querySelector('.worker-id');
                return workerIdSpan ? workerIdSpan.textContent.replace('Worker ID: ', '') : null;
            }).filter(id => id !== null);
            
            // åˆ›å»ºworker IDåˆ°æ•°æ®çš„æ˜ å°„
            const workerMap = {};
            workers.forEach(worker => {
                workerMap[worker.id] = worker;
            });
            
            // æ›´æ–°ç°æœ‰çš„workerå¡ç‰‡
            existingCards.forEach(card => {
                const workerIdSpan = card.querySelector('.worker-id');
                if (workerIdSpan) {
                    const workerId = workerIdSpan.textContent.replace('Worker ID: ', '');
                    const workerData = workerMap[workerId];
                    
                    if (workerData) {
                        // æ›´æ–°ç°æœ‰workerçš„ä¿¡æ¯
                        updateWorkerCard(card, workerData);
                        // ä»æ˜ å°„ä¸­ç§»é™¤å·²å¤„ç†çš„worker
                        delete workerMap[workerId];
                    } else {
                        // workerå·²ç¦»çº¿ï¼Œç§»é™¤å¡ç‰‡
                        card.remove();
                    }
                }
            });
            
            // æ·»åŠ æ–°çš„workerå¡ç‰‡ï¼ˆä¿æŒåœ¨ç°æœ‰workerä¹‹åï¼‰
            Object.values(workerMap).forEach(worker => {
                const newCard = createWorkerCard(worker);
                container.appendChild(newCard);
            });
        }
        
        function createWorkerCard(worker) {
            const card = document.createElement('div');
            card.className = 'worker-card';
            
            let html = '<div class="worker-header">';
            html += '<span class="worker-id">Worker ID: ' + worker.id + '</span>';
            html += '<span class="worker-status">åœ¨çº¿</span>';
            html += '<div style="clear: both; margin-top: 10px; color: #6c757d; font-size: 0.9em;">';
            html += 'æœ€åå¿ƒè·³: ' + new Date(worker.lastPing).toLocaleString();
            html += ' | ä»»åŠ¡æ•°: ' + worker.count;
            html += '</div></div>';
            html += '<div class="methods-list">';
            
            worker.methods.forEach(function(method, index) {
                const methodId = 'method-' + worker.id + '-' + index;
                html += '<div class="method-item">';
                html += '<div class="method-name">';
                html += 'ğŸ“Œ ' + method.name;
                html += '<button class="method-toggle-btn" onclick="toggleMethodDocs(\'' + methodId + '\')">';
                html += 'å±•å¼€</button>';
                html += '<button class="method-debug-btn" onclick="selectMethodForDebug(\'' + method.name + '\')">';
                html += 'ğŸ”§ è°ƒè¯•</button>';
                html += '</div>';
                html += '<div class="method-docs" id="' + methodId + '">';
                if (method.docs && method.docs.length > 0) {
                        html += marked.parse(method.docs.join('\n')); // ä½¿ç”¨markedåº“è§£æmarkdownæ ¼å¼æ–‡æ¡£
                } else {
                    html += 'æš‚æ— æ–‡æ¡£è¯´æ˜';
                }
                html += '</div></div>';
            });
            
            html += '</div>';
            card.innerHTML = html;
            return card;
        }
        
        function updateWorkerCard(card, worker) {
            // æ›´æ–°workerçŠ¶æ€ä¿¡æ¯
            const statusDiv = card.querySelector('.worker-header > div');
            if (statusDiv) {
                statusDiv.innerHTML = 'æœ€åå¿ƒè·³: ' + new Date(worker.lastPing).toLocaleString() + ' | ä»»åŠ¡æ•°: ' + worker.count;
            }
            
            // æ›´æ–°æ–¹æ³•åˆ—è¡¨
            const methodsList = card.querySelector('.methods-list');
            if (methodsList) {
                // ä¿å­˜å½“å‰å±•å¼€çŠ¶æ€
                const expandedStates = {};
                const existingDocs = methodsList.querySelectorAll('.method-docs');
                existingDocs.forEach(doc => {
                    if (doc.classList.contains('expanded')) {
                        // ä»IDä¸­æå–æ–¹æ³•ç´¢å¼•
                        const idParts = doc.id.split('-');
                        if (idParts.length >= 3) {
                            const methodIndex = idParts[idParts.length - 1];
                            expandedStates[methodIndex] = true;
                        }
                    }
                });
                
                let html = '';
                worker.methods.forEach(function(method, index) {
                    const methodId = 'method-' + worker.id + '-' + index;
                    const isExpanded = expandedStates[index.toString()];
                    
                    html += '<div class="method-item">';
                    html += '<div class="method-name">';
                    html += 'ğŸ“Œ ' + method.name;
                    html += '<button class="method-toggle-btn" onclick="toggleMethodDocs(\'' + methodId + '\')">';
                    html += isExpanded ? 'éšè—' : 'å±•å¼€';
                    html += '</button>';
                    html += '<button class="method-debug-btn" onclick="selectMethodForDebug(\'' + method.name + '\')">';
                    html += 'ğŸ”§ è°ƒè¯•</button>';
                    html += '</div>';
                    html += '<div class="method-docs' + (isExpanded ? ' expanded' : '') + '" id="' + methodId + '">';
                    if (method.docs && method.docs.length > 0) {
                        html += marked.parse(method.docs.join('\n')); 
                    } else {
                        html += 'æš‚æ— æ–‡æ¡£è¯´æ˜';
                    }
                    html += '</div></div>';
                });
                methodsList.innerHTML = html;
            }
        }

        function updateMethodSelect(methods) {
            const select = document.getElementById('methodSelect');
            const batchSelect = document.getElementById('batchMethodSelect');
            const currentValue = select.value; // ä¿å­˜å½“å‰é€‰æ‹©çš„å€¼
            const currentBatchValue = batchSelect.value; // ä¿å­˜å½“å‰æ‰¹é‡é€‰æ‹©çš„å€¼
            
            // æ›´æ–°è°ƒè¯•æ¨¡å¼çš„æ–¹æ³•é€‰æ‹©
            select.innerHTML = '<option value="">è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–¹æ³•</option>';
            // æ›´æ–°æ‰¹é‡æ¨¡å¼çš„æ–¹æ³•é€‰æ‹©
            batchSelect.innerHTML = '<option value="">è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–¹æ³•</option>';
            
            methods.forEach(function(method) {
                const option = document.createElement('option');
                option.value = method.name;
                option.textContent = method.name;
                select.appendChild(option);
                
                const batchOption = document.createElement('option');
                batchOption.value = method.name;
                batchOption.textContent = method.name;
                batchSelect.appendChild(batchOption);
            });
            
            // æ¢å¤ä¹‹å‰é€‰æ‹©çš„å€¼ï¼ˆå¦‚æœè¯¥æ–¹æ³•ä»ç„¶å­˜åœ¨ï¼‰
            if (currentValue && methods.find(m => m.name === currentValue)) {
                select.value = currentValue;
            }
            if (currentBatchValue && methods.find(m => m.name === currentBatchValue)) {
                batchSelect.value = currentBatchValue;
            }
            
            // åŒæ—¶æ›´æ–°ä»»åŠ¡å¼¹æ¡†ä¸­çš„æ–¹æ³•é€‰æ‹©å™¨
            updateTaskMethodSelect();
        }
        
        function selectMethodForDebug(methodName) {
            document.getElementById('methodSelect').value = methodName;
            // æ»šåŠ¨åˆ°è°ƒè¯•åŒºåŸŸ
            document.querySelector('.debug-section').scrollIntoView({ behavior: 'smooth' });
        }
        
        function toggleMethodDocs(methodId) {
            const docsElement = document.getElementById(methodId);
            const toggleBtn = event.target;
            
            if (docsElement.classList.contains('expanded')) {
                docsElement.classList.remove('expanded');
                toggleBtn.textContent = 'å±•å¼€';
            } else {
                docsElement.classList.add('expanded');
                toggleBtn.textContent = 'éšè—';
            }
        }
        
        function executeMethod() {
            const methodName = document.getElementById('methodSelect').value;
            const paramsText = document.getElementById('paramsInput').value;
            const timeout = parseInt(document.getElementById('timeoutInput').value);
            const resultArea = document.getElementById('resultArea');
            const executeBtn = document.getElementById('executeBtn');
            
            if (!methodName) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–¹æ³•');
                return;
            }
            
            let params;
            try {
                params = paramsText ? JSON.parse(paramsText) : {};
            } catch (e) {
                params = `"${paramsText}"`
            }
            
            executeBtn.disabled = true;
            executeBtn.textContent = 'â³ æ‰§è¡Œä¸­...';
            resultArea.style.display = 'block';
            resultArea.className = 'result-area';
            resultArea.textContent = 'æ­£åœ¨æ‰§è¡Œæ–¹æ³•: ' + methodName + '\nå‚æ•°: ' + JSON.stringify(params, null, 2) + '\n\nç­‰å¾…ç»“æœ...';
            
            // æäº¤ä»»åŠ¡
            fetch('/api/execute', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    method: methodName,
                    params: params,
                    timeout: timeout
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    executeBtn.disabled = false;
                    executeBtn.textContent = 'ğŸš€ æ‰§è¡Œæ–¹æ³•';
                    resultArea.className = 'result-area result-error';
                    resultArea.textContent = 'âŒ æäº¤ä»»åŠ¡å¤±è´¥:\n' + data.error;
                    return;
                }
                
                // å¼€å§‹è½®è¯¢ä»»åŠ¡ç»“æœ
                const taskId = data.taskId;
                pollTaskResult(taskId, timeout * 1000, executeBtn, resultArea);
            })
            .catch(error => {
                executeBtn.disabled = false;
                executeBtn.textContent = 'ğŸš€ æ‰§è¡Œæ–¹æ³•';
                resultArea.className = 'result-area result-error';
                resultArea.textContent = 'âŒ ç½‘ç»œé”™è¯¯:\n' + error.message;
            });
        }
        
        function pollTaskResult(taskId, timeoutMs, executeBtn, resultArea) {
            const startTime = Date.now();
            const pollInterval = 500; // æ¯500msè½®è¯¢ä¸€æ¬¡
            
            function poll() {
                if (Date.now() - startTime > timeoutMs) {
                    executeBtn.disabled = false;
                    executeBtn.textContent = 'ğŸš€ æ‰§è¡Œæ–¹æ³•';
                    resultArea.className = 'result-area result-error';
                    resultArea.textContent = 'âŒ ä»»åŠ¡æ‰§è¡Œè¶…æ—¶';
                    return;
                }
                
                fetch('/api/result/' + taskId)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'done') {
                            executeBtn.disabled = false;
                            executeBtn.textContent = 'ğŸš€ æ‰§è¡Œæ–¹æ³•';
                            resultArea.className = 'result-area result-success';
                            resultArea.textContent = 'âœ… æ‰§è¡ŒæˆåŠŸ:\n' + JSON.stringify(data.result, null, 2);
                            
                            // ä¿å­˜è°ƒè¯•ç»“æœ
                            const methodName = document.getElementById('methodSelect').value;
                            let params 
                            try{
                                params = JSON.parse(document.getElementById('paramsInput').value);
                            }catch(e){
                                params = `"${document.getElementById('paramsInput').value}"`;
                            }
                            debugResults.push({
                                timestamp: new Date().toISOString(),
                                method: methodName,
                                params: params,
                                result: data.result,
                                success: true,
                                taskId: taskId
                            });
                            
                            // æ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
                            document.getElementById('debugExportButtons').style.display = 'flex';
                        } else if (data.status === 'error') {
                            executeBtn.disabled = false;
                            executeBtn.textContent = 'ğŸš€ æ‰§è¡Œæ–¹æ³•';
                            resultArea.className = 'result-area result-error';
                            resultArea.textContent = 'âŒ æ‰§è¡Œå¤±è´¥:\n' + JSON.stringify(data.result, null, 2);
                            
                            // ä¿å­˜è°ƒè¯•ç»“æœ
                            const methodName = document.getElementById('methodSelect').value;
                            const params = JSON.parse(document.getElementById('paramsInput').value);
                            debugResults.push({
                                timestamp: new Date().toISOString(),
                                method: methodName,
                                params: params,
                                result: data.result,
                                success: false,
                                taskId: taskId,
                                error: data.result
                            });
                            
                            // æ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
                            document.getElementById('debugExportButtons').style.display = 'flex';
                        } else {
                            // ä»»åŠ¡è¿˜åœ¨å¤„ç†ä¸­ï¼Œç»§ç»­è½®è¯¢
                            setTimeout(poll, pollInterval);
                        }
                    })
                    .catch(error => {
                        executeBtn.disabled = false;
                        executeBtn.textContent = 'ğŸš€ æ‰§è¡Œæ–¹æ³•';
                        resultArea.className = 'result-area result-error';
                        resultArea.textContent = 'âŒ è·å–ç»“æœå¤±è´¥:\n' + error.message;
                    });
            }
            
            poll();
        }
        
        // é€‰é¡¹å¡åˆ‡æ¢åŠŸèƒ½
        function switchTab(tabName) {
            // ç§»é™¤æ‰€æœ‰é€‰é¡¹å¡æŒ‰é’®çš„activeç±»
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // éšè—æ‰€æœ‰é€‰é¡¹å¡å†…å®¹
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // æ¿€æ´»å½“å‰é€‰é¡¹å¡
            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }
        
        // æ‰¹é‡æ‰§è¡Œæ–¹æ³•
        function executeBatchMethod() {
            const methodName = document.getElementById('batchMethodSelect').value;
            const paramsText = document.getElementById('batchParamsInput').value;
            const timeout = parseInt(document.getElementById('batchTimeoutInput').value);
            const concurrency = parseInt(document.getElementById('concurrencyInput').value);
            const intervalText = document.getElementById('intervalInput').value.trim();
            const randomOrder = document.getElementById('randomOrderInput').checked;
            const resultArea = document.getElementById('batchResultArea');
            const executeBtn = document.getElementById('batchExecuteBtn');
            
            if (!methodName) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–¹æ³•');
                return;
            }
            
            let paramsList;
            try {
                paramsList = paramsText ? JSON.parse(paramsText) : [];
                if (!Array.isArray(paramsList)) {
                    throw new Error('å‚æ•°å¿…é¡»æ˜¯æ•°ç»„æ ¼å¼');
                }
            } catch (e) {
                alert('å‚æ•°æ ¼å¼é”™è¯¯ï¼Œè¯·è¾“å…¥æœ‰æ•ˆçš„JSONæ•°ç»„æ ¼å¼');
                return;
            }
            
            if (paramsList.length === 0) {
                alert('å‚æ•°åˆ—è¡¨ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            // è§£ææ‰§è¡Œé—´éš”
            let intervalConfig = { type: 'fixed', value: 0 };
            if (intervalText && intervalText !== '0') {
                if (intervalText.includes('-')) {
                    const parts = intervalText.split('-');
                    if (parts.length === 2) {
                        const min = parseInt(parts[0].trim());
                        const max = parseInt(parts[1].trim());
                        if (!isNaN(min) && !isNaN(max) && min >= 0 && max >= min) {
                            intervalConfig = { type: 'random', min: min, max: max };
                        } else {
                            alert('é—´éš”èŒƒå›´æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨å¦‚ "500-2000" çš„æ ¼å¼');
                            return;
                        }
                    } else {
                        alert('é—´éš”èŒƒå›´æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨å¦‚ "500-2000" çš„æ ¼å¼');
                        return;
                    }
                } else {
                    const fixedInterval = parseInt(intervalText);
                    if (!isNaN(fixedInterval) && fixedInterval >= 0) {
                        intervalConfig = { type: 'fixed', value: fixedInterval };
                    } else {
                        alert('å›ºå®šé—´éš”å¿…é¡»æ˜¯éè´Ÿæ•´æ•°');
                        return;
                    }
                }
            }
            
            executeBtn.disabled = true;
            executeBtn.textContent = 'â³ æ‰¹é‡æ‰§è¡Œä¸­...';
            resultArea.style.display = 'block';
            resultArea.className = 'result-area';
            
            const intervalInfo = intervalConfig.type === 'fixed' ? 
                (intervalConfig.value > 0 ? `${intervalConfig.value}æ¯«ç§’` : 'æ— é—´éš”') :
                `${intervalConfig.min}-${intervalConfig.max}æ¯«ç§’éšæœº`;
            
            resultArea.innerHTML = `
                <div>æ­£åœ¨æ‰¹é‡æ‰§è¡Œæ–¹æ³•: ${methodName}</div>
                <div>æ€»ä»»åŠ¡æ•°: ${paramsList.length}</div>
                <div>å¹¶å‘æ•°: ${concurrency}</div>
                <div>å•æ¬¡è¶…æ—¶: ${timeout}ç§’</div>
                <div>æ‰§è¡Œé—´éš”: ${intervalInfo}</div>
                <div>æ‰§è¡Œé¡ºåº: ${randomOrder ? 'éšæœº' : 'é¡ºåº'}</div>
                <hr>
                <div id="batchProgress">å‡†å¤‡æ‰§è¡Œ...</div>
                <div id="batchResults"></div>
            `;
            
            executeBatchTasks(methodName, paramsList, timeout, concurrency, intervalConfig, randomOrder, executeBtn, resultArea);
        }
        
        // æ‰¹é‡æ‰§è¡Œä»»åŠ¡çš„æ ¸å¿ƒé€»è¾‘
        async function executeBatchTasks(methodName, paramsList, timeout, concurrency, intervalConfig, randomOrder, executeBtn, resultArea) {
            const progressDiv = document.getElementById('batchProgress');
            const resultsDiv = document.getElementById('batchResults');
            const results = [];
            let completed = 0;
            let failed = 0;
            let executionCounter = 0; // æ‰§è¡Œè®¡æ•°å™¨ï¼Œç”¨äºè®°å½•æ‰§è¡Œé¡ºåº
            
            // å‡†å¤‡æ‰§è¡Œé¡ºåº
            let executionOrder;
            if (randomOrder) {
                // åˆ›å»ºéšæœºé¡ºåºçš„ç´¢å¼•æ•°ç»„
                executionOrder = Array.from({length: paramsList.length}, (_, i) => i);
                // Fisher-Yates æ´—ç‰Œç®—æ³•
                for (let i = executionOrder.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [executionOrder[i], executionOrder[j]] = [executionOrder[j], executionOrder[i]];
                }
                console.log(executionOrder)
            } else {
                // é¡ºåºæ‰§è¡Œ
                executionOrder = Array.from({length: paramsList.length}, (_, i) => i);
            }
            
            // è·å–æ‰§è¡Œé—´éš”çš„å‡½æ•°
            function getInterval() {
                if (intervalConfig.type === 'fixed') {
                    return intervalConfig.value;
                } else {
                    return Math.floor(Math.random() * (intervalConfig.max - intervalConfig.min + 1)) + intervalConfig.min;
                }
            }
            
            // åˆ†æ‰¹æ‰§è¡Œä»»åŠ¡
            for (let i = 0; i < executionOrder.length; i += concurrency) {
                const batchIndices = executionOrder.slice(i, i + concurrency);
                const batchPromises = batchIndices.map(async (originalIndex, batchIndex) => {
                    const params = paramsList[originalIndex];
                    
                    try {
                        // å¦‚æœä¸æ˜¯ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œéœ€è¦ç­‰å¾…é—´éš”
                        if (i + batchIndex > 0) {
                            const interval = getInterval();
                            if (interval > 0) {
                                progressDiv.innerHTML = `ç­‰å¾… ${interval}ms åæ‰§è¡Œç¬¬ ${originalIndex + 1}/${paramsList.length} ä¸ªä»»åŠ¡...`;
                                await new Promise(resolve => setTimeout(resolve, interval));
                            }
                        }
                        
                        progressDiv.innerHTML = `æ­£åœ¨æ‰§è¡Œç¬¬ ${originalIndex + 1}/${paramsList.length} ä¸ªä»»åŠ¡... (${randomOrder ? 'éšæœºé¡ºåº' : 'é¡ºåºæ‰§è¡Œ'})`;
                        console.log(params)
                        // æäº¤ä»»åŠ¡
                        const response = await fetch('/api/execute', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                method: methodName,
                                params: params,
                                timeout: timeout
                            })
                        });
                        
                        const data = await response.json();
                        if (data.error) {
                            throw new Error(data.error);
                        }
                        
                        // ç­‰å¾…ä»»åŠ¡å®Œæˆ
                        const result = await pollTaskResultAsync(data.taskId, timeout * 1000);
                        
                        completed++;
                        const currentExecutionOrder = ++executionCounter;
                        results[originalIndex] = {
                            index: originalIndex,
                            executionOrder: currentExecutionOrder,
                            params: params,
                            success: true,
                            result: result
                        };
                        
                        // æ›´æ–°ç»“æœæ˜¾ç¤º
                        updateBatchResults(resultsDiv, results, completed, failed, paramsList.length);
                        
                    } catch (error) {
                        failed++;
                        const currentExecutionOrder = ++executionCounter;
                        results[originalIndex] = {
                            index: originalIndex,
                            executionOrder: currentExecutionOrder,
                            params: params,
                            success: false,
                            error: error.message
                        };
                        
                        // æ›´æ–°ç»“æœæ˜¾ç¤º
                        updateBatchResults(resultsDiv, results, completed, failed, paramsList.length);
                    }
                });
                
                // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                await Promise.all(batchPromises);
            }
            
            // æ‰§è¡Œå®Œæˆ
            executeBtn.disabled = false;
            executeBtn.textContent = 'ğŸš€ æ‰¹é‡æ‰§è¡Œ';
            progressDiv.innerHTML = `âœ… æ‰¹é‡æ‰§è¡Œå®Œæˆï¼æˆåŠŸ: ${completed}, å¤±è´¥: ${failed}`;
            
            if (failed === 0) {
                resultArea.className = 'result-area result-success';
            } else if (completed === 0) {
                resultArea.className = 'result-area result-error';
            } else {
                resultArea.className = 'result-area';
            }
        }
        
        // å¼‚æ­¥è½®è¯¢ä»»åŠ¡ç»“æœ
        function pollTaskResultAsync(taskId, timeoutMs) {
            return new Promise((resolve, reject) => {
                const startTime = Date.now();
                const pollInterval = 500;
                
                function poll() {
                    if (Date.now() - startTime > timeoutMs) {
                        reject(new Error('ä»»åŠ¡æ‰§è¡Œè¶…æ—¶'));
                        return;
                    }
                    
                    fetch('/api/result/' + taskId)
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'done') {
                                resolve(data.result);
                            } else if (data.status === 'error') {
                                reject(new Error(JSON.stringify(data.result)));
                            } else {
                                setTimeout(poll, pollInterval);
                            }
                        })
                        .catch(error => {
                            reject(error);
                        });
                }
                
                poll();
            });
        }
        
        // æ›´æ–°æ‰¹é‡æ‰§è¡Œç»“æœæ˜¾ç¤º
        function updateBatchResults(resultsDiv, results, completed, failed, total) {
            let html = `<div style="margin: 10px 0; font-weight: bold;">è¿›åº¦: ${completed + failed}/${total} (æˆåŠŸ: ${completed}, å¤±è´¥: ${failed})</div>`;
            
            // è¿‡æ»¤å‡ºå·²å®Œæˆçš„ç»“æœå¹¶æŒ‰æ‰§è¡Œé¡ºåºæ’åº
            const completedResults = results.filter(result => result !== undefined)
                .sort((a, b) => a.executionOrder - b.executionOrder);
            
            completedResults.forEach((result) => {
                html += `<div style="margin: 5px 0; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">`;
                html += `<strong>æ‰§è¡Œé¡ºåº ${result.executionOrder} (åŸå§‹ä»»åŠ¡ ${result.index + 1}):</strong> `;
                if (result.success) {
                    html += `<span style="color: green;">âœ… æˆåŠŸ</span><br>`;
                    html += `<small>å‚æ•°: ${JSON.stringify(result.params)}</small><br>`;
                    html += `<small>ç»“æœ: ${JSON.stringify(result.result)}</small>`;
                } else {
                    html += `<span style="color: red;">âŒ å¤±è´¥</span><br>`;
                    html += `<small>å‚æ•°: ${JSON.stringify(result.params)}</small><br>`;
                    html += `<small>é”™è¯¯: ${result.error}</small>`;
                }
                html += `</div>`;
            });
            
            resultsDiv.innerHTML = html;
            
            // å¦‚æœæ‰¹é‡æ‰§è¡Œå®Œæˆï¼Œä¿å­˜ç»“æœæ•°æ®å¹¶æ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
            if (completed + failed === total) {
                const methodName = document.getElementById('batchMethodSelect').value;
                
                // æ¸…ç©ºä¹‹å‰çš„æ‰¹é‡ç»“æœ
                batchResults = [];
                
                // ä¿å­˜æ‰€æœ‰ç»“æœ
                completedResults.forEach(result => {
                    batchResults.push({
                        timestamp: new Date().toISOString(),
                        method: methodName,
                        params: result.params,
                        result: result.result,
                        success: result.success,
                        executionOrder: result.executionOrder,
                        originalIndex: result.index,
                        error: result.error || null
                    });
                });
                
                // æ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
                document.getElementById('batchExportButtons').style.display = 'flex';
            }
        }
        
        // é˜²æŠ–å®šæ—¶å™¨
        let formatTimers = {};
        
        // è‡ªåŠ¨JSONæ ¼å¼åŒ–åŠŸèƒ½
        function autoFormatJSON(textareaId) {
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (formatTimers[textareaId]) {
                clearTimeout(formatTimers[textareaId]);
            }
            
            // è®¾ç½®æ–°çš„å®šæ—¶å™¨ï¼Œ1ç§’åæ‰§è¡Œæ ¼å¼åŒ–
            formatTimers[textareaId] = setTimeout(() => {
                const textarea = document.getElementById(textareaId);
                const value = textarea.value.trim();
                
                if (!value) {
                    return;
                }
                
                try {
                    const parsed = JSON.parse(value);
                    const formatted = JSON.stringify(parsed, null, 2);
                    if (textarea.value !== formatted) {
                        const cursorPos = textarea.selectionStart;
                        textarea.value = formatted;
                        // å°è¯•ä¿æŒå…‰æ ‡ä½ç½®
                        textarea.setSelectionRange(cursorPos, cursorPos);
                    }
                } catch (error) {
                    // é™é»˜å¤„ç†é”™è¯¯ï¼Œä¸æ˜¾ç¤ºå¼¹çª—
                }
            }, 1000);
        }
        
        // JSONé¢„è§ˆåŠŸèƒ½
        function toggleJSONPreview(textareaId, previewId) {
            const textarea = document.getElementById(textareaId);
            const preview = document.getElementById(previewId);
            
            if (preview.style.display === 'none') {
                // æ˜¾ç¤ºé¢„è§ˆ
                const value = textarea.value.trim();
                if (!value) {
                    alert('è¯·å…ˆè¾“å…¥JSONå†…å®¹');
                    return;
                }
                
                try {
                    const parsed = JSON.parse(value);
                    const isBatch = textareaId.includes('batch');
                    const isMultiBatch = textareaId === 'multiBatchTasksInput';
                    preview.innerHTML = generateJSONPreview(parsed, isBatch, isMultiBatch);
                    preview.style.display = 'block';
                } catch (error) {
                    preview.innerHTML = '<div class="json-error">JSONæ ¼å¼é”™è¯¯: ' + error.message + '</div>';
                    preview.style.display = 'block';
                }
            } else {
                // éšè—é¢„è§ˆ
                preview.style.display = 'none';
            }
        }
        

        
        // ç”ŸæˆJSONé¢„è§ˆè¡¨æ ¼
        function generateJSONPreview(data, isBatch, isMultiBatch) {
            if (isMultiBatch && Array.isArray(data)) {
                // å¤šæ–¹æ³•æ‰¹é‡æ¨¡å¼ï¼šæ˜¾ç¤ºä»»åŠ¡é…ç½®é¢„è§ˆ
                let html = '<div style="padding: 10px;"><strong>å¤šæ–¹æ³•ä»»åŠ¡é…ç½®é¢„è§ˆ (å…± ' + data.length + ' ä¸ªä»»åŠ¡)</strong></div>';
                
                // ç»Ÿè®¡æ–¹æ³•åˆ†å¸ƒ
                const methodStats = {};
                data.forEach(task => {
                    if (task.method) {
                        methodStats[task.method] = (methodStats[task.method] || 0) + 1;
                    }
                });
                
                if (Object.keys(methodStats).length > 0) {
                    html += '<div style="padding: 10px; background: #e7f3ff; border-radius: 4px; margin: 10px;">';
                    html += '<strong>æ–¹æ³•åˆ†å¸ƒç»Ÿè®¡:</strong><br>';
                    Object.entries(methodStats).forEach(([method, count]) => {
                        html += `<span style="margin-right: 15px;">ğŸ“Œ ${method}: ${count}æ¬¡</span>`;
                    });
                    html += '</div>';
                }
                
                data.forEach((task, index) => {
                    html += '<div style="margin: 10px; padding: 10px; border: 1px solid #dee2e6; border-radius: 4px;">';
                    html += '<div style="font-weight: bold; margin-bottom: 8px; color: #495057;">ä»»åŠ¡ ' + (index + 1) + ':</div>';
                    
                    if (typeof task === 'object' && task !== null) {
                        // ç‰¹æ®Šå¤„ç†methodå’Œparamså­—æ®µ
                        if (task.method) {
                            html += '<div style="margin-bottom: 5px;"><strong>æ–¹æ³•:</strong> <span style="color: #007bff; font-family: monospace;">' + task.method + '</span></div>';
                        }
                        if (task.params !== undefined) {
                            html += '<div style="margin-bottom: 5px;"><strong>å‚æ•°:</strong></div>';
                            if (typeof task.params === 'object' && task.params !== null && Object.keys(task.params).length > 0) {
                                html += generateKeyValueTable(task.params);
                            } else {
                                html += '<div style="color: #6c757d; font-style: italic;">æ— å‚æ•°æˆ–ç©ºå¯¹è±¡</div>';
                            }
                        }
                        
                        // æ˜¾ç¤ºå…¶ä»–å­—æ®µ
                        const otherFields = Object.keys(task).filter(key => key !== 'method' && key !== 'params');
                        if (otherFields.length > 0) {
                            html += '<div style="margin-top: 10px;"><strong>å…¶ä»–å­—æ®µ:</strong></div>';
                            const otherData = {};
                            otherFields.forEach(key => {
                                otherData[key] = task[key];
                            });
                            html += generateKeyValueTable(otherData);
                        }
                    } else {
                        html += '<div class="json-value">å€¼: ' + JSON.stringify(task) + ' <span class="json-type">(" + typeof task + ")</span></div>';
                    }
                    
                    html += '</div>';
                });
                
                return html;
            } else if (isBatch && Array.isArray(data)) {
                // å•æ–¹æ³•æ‰¹é‡æ¨¡å¼ï¼šæ˜¾ç¤ºæ•°ç»„ä¸­æ¯ä¸ªå¯¹è±¡çš„é¢„è§ˆ
                let html = '<div style="padding: 10px;"><strong>æ‰¹é‡å‚æ•°é¢„è§ˆ (å…± ' + data.length + ' ç»„å‚æ•°)</strong></div>';
                
                data.forEach((item, index) => {
                    html += '<div style="margin: 10px; padding: 10px; border: 1px solid #dee2e6; border-radius: 4px;">';
                    html += '<div style="font-weight: bold; margin-bottom: 8px; color: #495057;">å‚æ•°ç»„ ' + (index + 1) + ':</div>';
                    
                    if (typeof item === 'object' && item !== null) {
                        html += generateKeyValueTable(item);
                    } else {
                        html += '<div class="json-value">å€¼: ' + JSON.stringify(item) + ' <span class="json-type">(" + typeof item + ")</span></div>';
                    }
                    
                    html += '</div>';
                });
                
                return html;
            } else {
                // å•ä¸ªæ¨¡å¼ï¼šæ˜¾ç¤ºå¯¹è±¡çš„key-valueè¡¨æ ¼
                if (typeof data === 'object' && data !== null) {
                    return '<div style="padding: 10px;"><strong>å‚æ•°é¢„è§ˆ:</strong></div>' + generateKeyValueTable(data);
                } else {
                    return '<div style="padding: 10px;"><div class="json-value">å€¼: ' + JSON.stringify(data) + ' <span class="json-type">(" + typeof data + ")</span></div></div>';
                }
            }
        }
        
        // ç”Ÿæˆkey-valueè¡¨æ ¼
        function generateKeyValueTable(obj) {
            let html = '<table class="json-preview-table">';
            html += '<thead><tr><th>é”® (Key)</th><th>å€¼ (Value)</th><th>ç±»å‹</th></tr></thead>';
            html += '<tbody>';
            
            function addRows(object, prefix = '') {
                for (const [key, value] of Object.entries(object)) {
                    const fullKey = prefix ? prefix + '.' + key : key;
                    
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        // åµŒå¥—å¯¹è±¡
                        html += '<tr>';
                        html += '<td class="json-key">' + fullKey + '</td>';
                        html += '<td class="json-value">{...} (åµŒå¥—å¯¹è±¡)</td>';
                        html += '<td class="json-type">object</td>';
                        html += '</tr>';
                        addRows(value, fullKey);
                    } else {
                        html += '<tr>';
                        html += '<td class="json-key">' + fullKey + '</td>';
                        html += '<td class="json-value">' + JSON.stringify(value) + '</td>';
                        html += '<td class="json-type">' + (Array.isArray(value) ? 'array' : typeof value) + '</td>';
                        html += '</tr>';
                    }
                }
            }
            
            addRows(obj);
            html += '</tbody></table>';
            return html;
        }
        
        // è‡ªåŠ¨æ ¼å¼åŒ–JSON
        function autoFormatJSON(inputId, previewId) {
            const input = document.getElementById(inputId);
            const preview = document.getElementById(previewId || inputId + 'Preview');
            
            try {
                const data = JSON.parse(input.value);
                input.value = JSON.stringify(data, null, 2);
                
                // æ›´æ–°é¢„è§ˆ
                const isBatch = inputId === 'batchParamsInput';
                const isMultiBatch = inputId === 'multiBatchTasksInput';
                if (preview) {
                    preview.innerHTML = generateJSONPreview(data, isBatch, isMultiBatch);
                    preview.style.display = 'block';
                }
            } catch (e) {
                if (preview) {
                    preview.innerHTML = '<div style="color: red; padding: 10px;">JSONæ ¼å¼é”™è¯¯: ' + e.message + '</div>';
                    preview.style.display = 'block';
                }
            }
        }
        
        // åˆ‡æ¢JSONé¢„è§ˆ
        function toggleJSONPreview(inputId, previewId) {
            const input = document.getElementById(inputId);
            const preview = document.getElementById(previewId);
            
            if (preview.style.display === 'none' || preview.style.display === '') {
                try {
                    const data = JSON.parse(input.value);
                    const isBatch = inputId === 'batchParamsInput';
                    const isMultiBatch = inputId === 'multiBatchTasksInput';
                    preview.innerHTML = generateJSONPreview(data, isBatch, isMultiBatch);
                    preview.style.display = 'block';
                } catch (e) {
                    preview.innerHTML = '<div style="color: red; padding: 10px;">JSONæ ¼å¼é”™è¯¯: ' + e.message + '</div>';
                    preview.style.display = 'block';
                }
            } else {
                preview.style.display = 'none';
            }
        }
        
        // å¤šæ–¹æ³•æ‰¹é‡è¿è¡ŒJSONé¢„è§ˆ
        function toggleMultiBatchTasksPreview() {
            toggleJSONPreview('multiBatchTasksInput', 'multiBatchTasksPreview');
        }
        
        // å¤šæ–¹æ³•æ‰¹é‡è¿è¡Œä»»åŠ¡ç®¡ç†
        let editingTaskIndex = -1;
        
        // æ˜¾ç¤ºæ·»åŠ ä»»åŠ¡å¼¹æ¡†
        function showAddTaskModal() {
            editingTaskIndex = -1;
            document.getElementById('modalTitle').textContent = 'æ·»åŠ ä»»åŠ¡';
            document.getElementById('saveTaskBtn').textContent = 'ä¿å­˜';
            
            // é‡ç½®è¡¨å•
            document.getElementById('taskMethodSelect').value = '';
            document.getElementById('taskParamsInput').value = '[{}]';
            document.getElementById('taskParamsPreview').style.display = 'none';
            
            // æ›´æ–°æ–¹æ³•é€‰æ‹©å™¨
            updateTaskMethodSelect();
            
            document.getElementById('addTaskModal').style.display = 'flex';
        }
        
        // æ˜¾ç¤ºç¼–è¾‘ä»»åŠ¡å¼¹æ¡†
        function showEditTaskModal(index) {
            editingTaskIndex = index;
            const task = multiBatchTasks[index];
            
            document.getElementById('modalTitle').textContent = 'ç¼–è¾‘ä»»åŠ¡';
            document.getElementById('saveTaskBtn').textContent = 'æ›´æ–°';
            
            // æ›´æ–°æ–¹æ³•é€‰æ‹©å™¨
            updateTaskMethodSelect();
            
            // å¡«å……è¡¨å•
            document.getElementById('taskMethodSelect').value = task.method;
            // å…¼å®¹æ—§æ ¼å¼ï¼ˆparamsï¼‰å’Œæ–°æ ¼å¼ï¼ˆparamsListï¼‰
            const paramsToShow = task.paramsList || (task.params ? [task.params] : [{}]);
            document.getElementById('taskParamsInput').value = JSON.stringify(paramsToShow, null, 2);
            document.getElementById('taskParamsPreview').style.display = 'none';
            
            document.getElementById('addTaskModal').style.display = 'flex';
        }
        
        // å…³é—­å¼¹æ¡†
        function closeAddTaskModal() {
            document.getElementById('addTaskModal').style.display = 'none';
            editingTaskIndex = -1;
        }
        
        // æ›´æ–°ä»»åŠ¡æ–¹æ³•é€‰æ‹©å™¨
        function updateTaskMethodSelect() {
            const methodSelect = document.getElementById('methodSelect');
            const taskMethodSelect = document.getElementById('taskMethodSelect');
            const currentTaskValue = taskMethodSelect.value; // ä¿å­˜å½“å‰é€‰æ‹©çš„å€¼
            
            // æ¸…ç©ºé€‰é¡¹
            taskMethodSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ–¹æ³•</option>';
            
            // å¤åˆ¶ä¸»æ–¹æ³•é€‰æ‹©å™¨çš„é€‰é¡¹
            Array.from(methodSelect.options).forEach(option => {
                if (option.value !== '') {
                    const newOption = document.createElement('option');
                    newOption.value = option.value;
                    newOption.textContent = option.textContent;
                    taskMethodSelect.appendChild(newOption);
                }
            });
            
            // æ¢å¤ä¹‹å‰é€‰æ‹©çš„å€¼ï¼ˆå¦‚æœè¯¥æ–¹æ³•ä»ç„¶å­˜åœ¨ï¼‰
            if (currentTaskValue && Array.from(taskMethodSelect.options).find(option => option.value === currentTaskValue)) {
                taskMethodSelect.value = currentTaskValue;
            }
        }
        
        // æ›´æ–°ä»»åŠ¡å‚æ•°è¾“å…¥æ¡†
        function updateTaskParamsInput() {
            const methodSelect = document.getElementById('taskMethodSelect');
            const paramsInput = document.getElementById('taskParamsInput');
            
            if (methodSelect.value && paramsInput.value.trim() === '{}') {
                // å¯ä»¥æ ¹æ®æ–¹æ³•æä¾›é»˜è®¤å‚æ•°æ¨¡æ¿
                paramsInput.value = '{}';
            }
        }
        
        // æ ¼å¼åŒ–ä»»åŠ¡å‚æ•°
        function formatTaskParams() {
            const input = document.getElementById('taskParamsInput');
            try {
                const data = JSON.parse(input.value);
                input.value = JSON.stringify(data, null, 2);
            } catch (e) {
                alert('JSONæ ¼å¼é”™è¯¯: ' + e.message);
            }
        }
        
        // åˆ‡æ¢ä»»åŠ¡å‚æ•°é¢„è§ˆ
        function toggleTaskParamsPreview() {
            const input = document.getElementById('taskParamsInput');
            const preview = document.getElementById('taskParamsPreview');
            
            if (preview.style.display === 'none' || preview.style.display === '') {
                try {
                    const data = JSON.parse(input.value);
                    preview.innerHTML = generateJSONPreview(data, false, false);
                    preview.style.display = 'block';
                } catch (e) {
                    preview.innerHTML = '<div style="color: red; padding: 10px;">JSONæ ¼å¼é”™è¯¯: ' + e.message + '</div>';
                    preview.style.display = 'block';
                }
            } else {
                preview.style.display = 'none';
            }
        }
        
        // ä¿å­˜ä»»åŠ¡
        function saveTask() {
            const method = document.getElementById('taskMethodSelect').value;
            const paramsText = document.getElementById('taskParamsInput').value;
            
            if (!method) {
                alert('è¯·é€‰æ‹©æ–¹æ³•');
                return;
            }
            
            let paramsList;
            try {
                paramsList = JSON.parse(paramsText);
                if (!Array.isArray(paramsList)) {
                    throw new Error('å‚æ•°å¿…é¡»æ˜¯æ•°ç»„æ ¼å¼');
                }
            } catch (e) {
                alert('å‚æ•°JSONæ ¼å¼é”™è¯¯: ' + e.message);
                return;
            }
            
            const task = { method, paramsList };
            
            if (editingTaskIndex >= 0) {
                // ç¼–è¾‘æ¨¡å¼
                multiBatchTasks[editingTaskIndex] = task;
            } else {
                // æ·»åŠ æ¨¡å¼
                multiBatchTasks.push(task);
            }
            
            updateTasksTable();
            closeAddTaskModal();
        }
        
        // åˆ é™¤ä»»åŠ¡
        function deleteTask(index) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿ')) {
                multiBatchTasks.splice(index, 1);
                updateTasksTable();
            }
        }
        
        // æ›´æ–°ä»»åŠ¡è¡¨æ ¼
        function updateTasksTable() {
            const tbody = document.getElementById('multiBatchTasksTableBody');
            
            if (multiBatchTasks.length === 0) {
                tbody.innerHTML = '<tr class="no-tasks-row"><td colspan="4" style="text-align: center; color: #6c757d; font-style: italic; padding: 20px;">æš‚æ— ä»»åŠ¡ï¼Œç‚¹å‡»"æ·»åŠ ä»»åŠ¡"å¼€å§‹é…ç½®</td></tr>';
                return;
            }
            
            tbody.innerHTML = multiBatchTasks.map((task, index) => {
                // å…¼å®¹æ—§æ ¼å¼ï¼ˆparamsï¼‰å’Œæ–°æ ¼å¼ï¼ˆparamsListï¼‰
                const paramsList = task.paramsList || (task.params ? [task.params] : [{}]);
                const paramsCount = paramsList.length;
                const paramsDisplay = paramsCount === 0 
                    ? '<span style="color: #6c757d; font-style: italic;">æ— å‚æ•°</span>'
                    : `<div style="font-size: 0.9em; color: #495057;"><strong>${paramsCount}ä¸ªå‚æ•°ç»„åˆ</strong></div><div style="max-height: 100px; overflow-y: auto; font-size: 0.8em; color: #6c757d; margin-top: 5px;">${JSON.stringify(paramsList, null, 2)}</div>`;
                
                return `
                    <tr>
                        <td>${index + 1}</td>
                        <td><span class="task-method">${task.method}</span></td>
                        <td><div class="task-params">${paramsDisplay}</div></td>
                        <td>
                            <div class="task-actions">
                                <button class="task-btn edit" onclick="showEditTaskModal(${index})">âœï¸ ç¼–è¾‘</button>
                                <button class="task-btn delete" onclick="deleteTask(${index})">ğŸ—‘ï¸ åˆ é™¤</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        // å¤šæ–¹æ³•æ‰¹é‡æ‰§è¡Œ
        function executeMultiBatchMethod() {
            const timeout = parseInt(document.getElementById('multiBatchTimeoutInput').value);
            const concurrency = parseInt(document.getElementById('multiBatchConcurrencyInput').value);
            const intervalText = document.getElementById('multiBatchIntervalInput').value.trim();
            const randomOrder = document.getElementById('multiBatchRandomOrderInput').checked;
            const groupByMethod = document.getElementById('multiBatchGroupByMethodInput').checked;
            const resultArea = document.getElementById('multiBatchResultArea');
            const executeBtn = document.getElementById('multiBatchExecuteBtn');
            
            // ä½¿ç”¨è¡¨æ ¼ä¸­çš„ä»»åŠ¡é…ç½®
            const taskConfigs = [...multiBatchTasks]; // åˆ›å»ºå‰¯æœ¬
            
            if (taskConfigs.length === 0) {
                alert('è¯·å…ˆæ·»åŠ è‡³å°‘ä¸€ä¸ªä»»åŠ¡');
                return;
            }
            
            // å°†ä»»åŠ¡é…ç½®å±•å¼€ä¸ºå…·ä½“çš„æ‰§è¡Œä»»åŠ¡åˆ—è¡¨
            const tasksList = [];
            taskConfigs.forEach(taskConfig => {
                const method = taskConfig.method;
                // å…¼å®¹æ—§æ ¼å¼ï¼ˆparamsï¼‰å’Œæ–°æ ¼å¼ï¼ˆparamsListï¼‰
                const paramsList = taskConfig.paramsList || (taskConfig.params ? [taskConfig.params] : [{}]);
                
                paramsList.forEach(params => {
                    tasksList.push({ method, params });
                });
            });
            
            if (tasksList.length === 0) {
                 alert('ä»»åŠ¡é…ç½®ä¸­æ²¡æœ‰æœ‰æ•ˆçš„å‚æ•°');
                 return;
             }
            
            // è§£ææ‰§è¡Œé—´éš”
            let intervalConfig = { type: 'fixed', value: 0 };
            if (intervalText && intervalText !== '0') {
                if (intervalText.includes('-')) {
                    const parts = intervalText.split('-');
                    if (parts.length === 2) {
                        const min = parseInt(parts[0].trim());
                        const max = parseInt(parts[1].trim());
                        if (!isNaN(min) && !isNaN(max) && min >= 0 && max >= min) {
                            intervalConfig = { type: 'random', min: min, max: max };
                        } else {
                            alert('é—´éš”èŒƒå›´æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨å¦‚ "500-2000" çš„æ ¼å¼');
                            return;
                        }
                    } else {
                        alert('é—´éš”èŒƒå›´æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨å¦‚ "500-2000" çš„æ ¼å¼');
                        return;
                    }
                } else {
                    const fixedInterval = parseInt(intervalText);
                    if (!isNaN(fixedInterval) && fixedInterval >= 0) {
                        intervalConfig = { type: 'fixed', value: fixedInterval };
                    } else {
                        alert('å›ºå®šé—´éš”å¿…é¡»æ˜¯éè´Ÿæ•´æ•°');
                        return;
                    }
                }
            }
            
            executeBtn.disabled = true;
            executeBtn.textContent = 'â³ å¤šæ–¹æ³•æ‰¹é‡æ‰§è¡Œä¸­...';
            resultArea.style.display = 'block';
            resultArea.className = 'result-area';
            
            const intervalInfo = intervalConfig.type === 'fixed' ? 
                (intervalConfig.value > 0 ? `${intervalConfig.value}æ¯«ç§’` : 'æ— é—´éš”') :
                `${intervalConfig.min}-${intervalConfig.max}æ¯«ç§’éšæœº`;
            
            // ç»Ÿè®¡æ–¹æ³•åˆ†å¸ƒ
            const methodStats = {};
            tasksList.forEach(task => {
                methodStats[task.method] = (methodStats[task.method] || 0) + 1;
            });
            
            const methodStatsText = Object.entries(methodStats)
                .map(([method, count]) => `${method}(${count}æ¬¡)`)
                .join(', ');
            
            resultArea.innerHTML = `
                <div>æ­£åœ¨æ‰§è¡Œå¤šæ–¹æ³•æ‰¹é‡ä»»åŠ¡</div>
                <div>æ€»ä»»åŠ¡æ•°: ${tasksList.length}</div>
                <div>æ¶‰åŠæ–¹æ³•: ${methodStatsText}</div>
                <div>å¹¶å‘æ•°: ${concurrency}</div>
                <div>å•æ¬¡è¶…æ—¶: ${timeout}ç§’</div>
                <div>æ‰§è¡Œé—´éš”: ${intervalInfo}</div>
                <div>æ‰§è¡Œé¡ºåº: ${randomOrder ? 'éšæœº' : 'é¡ºåº'}</div>
                <div>ç»“æœæ˜¾ç¤º: ${groupByMethod ? 'æŒ‰æ–¹æ³•åˆ†ç»„' : 'æŒ‰æ‰§è¡Œé¡ºåº'}</div>
                <hr>
                <div id="multiBatchProgress">å‡†å¤‡æ‰§è¡Œ...</div>
                <div id="multiBatchResults"></div>
            `;
            
            executeMultiBatchTasks(tasksList, timeout, concurrency, intervalConfig, randomOrder, groupByMethod, executeBtn, resultArea);
        }
        
        // å¤šæ–¹æ³•æ‰¹é‡æ‰§è¡Œä»»åŠ¡çš„æ ¸å¿ƒé€»è¾‘
        async function executeMultiBatchTasks(tasksList, timeout, concurrency, intervalConfig, randomOrder, groupByMethod, executeBtn, resultArea) {
            const progressDiv = document.getElementById('multiBatchProgress');
            const resultsDiv = document.getElementById('multiBatchResults');
            const results = [];
            let completed = 0;
            let failed = 0;
            let executionCounter = 0;
            
            // å‡†å¤‡æ‰§è¡Œé¡ºåº
            let executionOrder;
            if (randomOrder) {
                executionOrder = Array.from({length: tasksList.length}, (_, i) => i);
                // Fisher-Yates æ´—ç‰Œç®—æ³•
                for (let i = executionOrder.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [executionOrder[i], executionOrder[j]] = [executionOrder[j], executionOrder[i]];
                }
            } else {
                executionOrder = Array.from({length: tasksList.length}, (_, i) => i);
            }
            
            // è·å–æ‰§è¡Œé—´éš”çš„å‡½æ•°
            function getInterval() {
                if (intervalConfig.type === 'fixed') {
                    return intervalConfig.value;
                } else {
                    return Math.floor(Math.random() * (intervalConfig.max - intervalConfig.min + 1)) + intervalConfig.min;
                }
            }
            
            // åˆ†æ‰¹æ‰§è¡Œä»»åŠ¡
            for (let i = 0; i < executionOrder.length; i += concurrency) {
                const batchIndices = executionOrder.slice(i, i + concurrency);
                const batchPromises = batchIndices.map(async (originalIndex, batchIndex) => {
                    const task = tasksList[originalIndex];
                    
                    try {
                        // å¦‚æœä¸æ˜¯ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œéœ€è¦ç­‰å¾…é—´éš”
                        if (i + batchIndex > 0) {
                            const interval = getInterval();
                            if (interval > 0) {
                                progressDiv.innerHTML = `ç­‰å¾… ${interval}ms åæ‰§è¡Œç¬¬ ${originalIndex + 1}/${tasksList.length} ä¸ªä»»åŠ¡ (${task.method})...`;
                                await new Promise(resolve => setTimeout(resolve, interval));
                            }
                        }
                        
                        progressDiv.innerHTML = `æ­£åœ¨æ‰§è¡Œç¬¬ ${originalIndex + 1}/${tasksList.length} ä¸ªä»»åŠ¡: ${task.method} (${randomOrder ? 'éšæœºé¡ºåº' : 'é¡ºåºæ‰§è¡Œ'})`;
                        
                        // æäº¤ä»»åŠ¡
                        const response = await fetch('/api/execute', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                method: task.method,
                                params: task.params,
                                timeout: timeout
                            })
                        });
                        
                        const data = await response.json();
                        if (data.error) {
                            throw new Error(data.error);
                        }
                        
                        // ç­‰å¾…ä»»åŠ¡å®Œæˆ
                        const result = await pollTaskResultAsync(data.taskId, timeout * 1000);
                        
                        completed++;
                        const currentExecutionOrder = ++executionCounter;
                        results[originalIndex] = {
                            index: originalIndex,
                            executionOrder: currentExecutionOrder,
                            method: task.method,
                            params: task.params,
                            success: true,
                            result: result
                        };
                        
                        // æ›´æ–°ç»“æœæ˜¾ç¤º
                        updateMultiBatchResults(resultsDiv, results, completed, failed, tasksList.length, groupByMethod);
                        
                    } catch (error) {
                        failed++;
                        const currentExecutionOrder = ++executionCounter;
                        results[originalIndex] = {
                            index: originalIndex,
                            executionOrder: currentExecutionOrder,
                            method: task.method,
                            params: task.params,
                            success: false,
                            error: error.message
                        };
                        
                        // æ›´æ–°ç»“æœæ˜¾ç¤º
                        updateMultiBatchResults(resultsDiv, results, completed, failed, tasksList.length, groupByMethod);
                    }
                });
                
                // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                await Promise.all(batchPromises);
            }
            
            // æ‰§è¡Œå®Œæˆ
            executeBtn.disabled = false;
            executeBtn.textContent = 'ğŸ¯ å¤šæ–¹æ³•æ‰¹é‡æ‰§è¡Œ';
            progressDiv.innerHTML = `âœ… å¤šæ–¹æ³•æ‰¹é‡æ‰§è¡Œå®Œæˆï¼æˆåŠŸ: ${completed}, å¤±è´¥: ${failed}`;
            
            if (failed === 0) {
                resultArea.className = 'result-area result-success';
            } else if (completed === 0) {
                resultArea.className = 'result-area result-error';
            } else {
                resultArea.className = 'result-area';
            }
        }
        
        // æ›´æ–°å¤šæ–¹æ³•æ‰¹é‡æ‰§è¡Œç»“æœæ˜¾ç¤º
        function updateMultiBatchResults(resultsDiv, results, completed, failed, total, groupByMethod) {
            let html = `<div style="margin: 10px 0; font-weight: bold;">è¿›åº¦: ${completed + failed}/${total} (æˆåŠŸ: ${completed}, å¤±è´¥: ${failed})</div>`;
            
            // è¿‡æ»¤å‡ºå·²å®Œæˆçš„ç»“æœ
            const completedResults = results.filter(result => result !== undefined);
            
            if (groupByMethod) {
                // æŒ‰æ–¹æ³•åˆ†ç»„æ˜¾ç¤º
                const groupedResults = {};
                completedResults.forEach(result => {
                    if (!groupedResults[result.method]) {
                        groupedResults[result.method] = [];
                    }
                    groupedResults[result.method].push(result);
                });
                
                Object.entries(groupedResults).forEach(([method, methodResults]) => {
                    html += `<div style="margin: 15px 0; padding: 10px; border: 2px solid #007bff; border-radius: 6px; background: #f8f9fa;">`;
                    html += `<h4 style="margin: 0 0 10px 0; color: #007bff;">ğŸ“Œ ${method} (${methodResults.length}ä¸ªä»»åŠ¡)</h4>`;
                    
                    // æŒ‰æ‰§è¡Œé¡ºåºæ’åº
                    methodResults.sort((a, b) => a.executionOrder - b.executionOrder);
                    
                    methodResults.forEach(result => {
                        html += generateResultItem(result);
                    });
                    
                    html += `</div>`;
                });
            } else {
                // æŒ‰æ‰§è¡Œé¡ºåºæ˜¾ç¤º
                const sortedResults = completedResults.sort((a, b) => a.executionOrder - b.executionOrder);
                sortedResults.forEach(result => {
                    html += generateResultItem(result);
                });
            }
            
            resultsDiv.innerHTML = html;
            
            // å¦‚æœå¤šæ–¹æ³•æ‰¹é‡æ‰§è¡Œå®Œæˆï¼Œä¿å­˜ç»“æœæ•°æ®å¹¶æ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
            if (completed + failed === total) {
                // æ¸…ç©ºä¹‹å‰çš„å¤šæ–¹æ³•æ‰¹é‡ç»“æœ
                multiBatchResults = [];
                
                // ä¿å­˜æ‰€æœ‰ç»“æœ
                completedResults.forEach(result => {
                    multiBatchResults.push({
                        timestamp: new Date().toISOString(),
                        method: result.method,
                        params: result.params,
                        result: result.result,
                        success: result.success,
                        executionOrder: result.executionOrder,
                        originalIndex: result.index,
                        error: result.error || null
                    });
                });
                
                // æ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
                document.getElementById('multiBatchExportButtons').style.display = 'flex';
            }
        }
        
        // ç”Ÿæˆå•ä¸ªç»“æœé¡¹çš„HTML
        function generateResultItem(result) {
            let html = `<div style="margin: 5px 0; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">`;
            html += `<strong>æ‰§è¡Œé¡ºåº ${result.executionOrder} (åŸå§‹ä»»åŠ¡ ${result.index + 1}) - ${result.method}:</strong> `;
            if (result.success) {
                html += `<span style="color: green;">âœ… æˆåŠŸ</span><br>`;
                html += `<small>å‚æ•°: ${JSON.stringify(result.params)}</small><br>`;
                html += `<small>ç»“æœ: ${JSON.stringify(result.result)}</small>`;
            } else {
                html += `<span style="color: red;">âŒ å¤±è´¥</span><br>`;
                html += `<small>å‚æ•°: ${JSON.stringify(result.params)}</small><br>`;
                html += `<small>é”™è¯¯: ${result.error}</small>`;
            }
            html += `</div>`;
            return html;
        }
        

        
        // å¯¼å‡ºåŠŸèƒ½å®ç°
        let debugResults = [];
        let batchResults = [];
        let multiBatchResults = [];
        
        // å¯¼å‡ºè°ƒè¯•ç»“æœ
        function exportDebugResult(type) {
            if (debugResults.length === 0) {
                alert('æ²¡æœ‰å¯å¯¼å‡ºçš„ç»“æœ');
                return;
            }
            
            let dataToExport = [];
            if (type === 'success') {
                dataToExport = debugResults.filter(r => r.success);
            } else if (type === 'failed') {
                dataToExport = debugResults.filter(r => !r.success);
            } else {
                dataToExport = debugResults;
            }
            
            if (dataToExport.length === 0) {
                alert(`æ²¡æœ‰${type === 'success' ? 'æˆåŠŸ' : type === 'failed' ? 'å¤±è´¥' : ''}çš„ç»“æœå¯å¯¼å‡º`);
                return;
            }
            
            exportToFile(dataToExport, `debug_results_${type}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`);
        }
        
        // å¯¼å‡ºæ‰¹é‡ç»“æœ
        function exportBatchResult(type) {
            if (batchResults.length === 0) {
                alert('æ²¡æœ‰å¯å¯¼å‡ºçš„ç»“æœ');
                return;
            }
            
            let dataToExport = [];
            if (type === 'success') {
                dataToExport = batchResults.filter(r => r.success);
            } else if (type === 'failed') {
                dataToExport = batchResults.filter(r => !r.success);
            } else {
                dataToExport = batchResults;
            }
            
            if (dataToExport.length === 0) {
                alert(`æ²¡æœ‰${type === 'success' ? 'æˆåŠŸ' : type === 'failed' ? 'å¤±è´¥' : ''}çš„ç»“æœå¯å¯¼å‡º`);
                return;
            }
            
            exportToFile(dataToExport, `batch_results_${type}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`);
        }
        
        // å¯¼å‡ºå¤šæ–¹æ³•æ‰¹é‡ç»“æœ
        function exportMultiBatchResult(type) {
            if (multiBatchResults.length === 0) {
                alert('æ²¡æœ‰å¯å¯¼å‡ºçš„ç»“æœ');
                return;
            }
            
            let dataToExport = [];
            if (type === 'success') {
                dataToExport = multiBatchResults.filter(r => r.success);
            } else if (type === 'failed') {
                dataToExport = multiBatchResults.filter(r => !r.success);
            } else {
                dataToExport = multiBatchResults;
            }
            
            if (dataToExport.length === 0) {
                alert(`æ²¡æœ‰${type === 'success' ? 'æˆåŠŸ' : type === 'failed' ? 'å¤±è´¥' : ''}çš„ç»“æœå¯å¯¼å‡º`);
                return;
            }
            
            exportToFile(dataToExport, `multi_batch_results_${type}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`);
        }
        
        // é€šç”¨å¯¼å‡ºæ–‡ä»¶å‡½æ•°
        function exportToFile(data, filename) {
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // é‡æ–°è¿è¡Œå¤±è´¥çš„è°ƒè¯•ä»»åŠ¡
        function retryFailedDebugTasks() {
            const failedTasks = debugResults.filter(r => !r.success);
            if (failedTasks.length === 0) {
                alert('æ²¡æœ‰å¤±è´¥çš„ä»»åŠ¡éœ€è¦é‡æ–°è¿è¡Œ');
                return;
            }
            
            if (!confirm(`ç¡®å®šè¦é‡æ–°è¿è¡Œ ${failedTasks.length} ä¸ªå¤±è´¥çš„ä»»åŠ¡å—ï¼Ÿ`)) {
                return;
            }
            
            // æ¸…ç©ºå½“å‰ç»“æœ
            debugResults = [];
            document.getElementById('debugExportButtons').style.display = 'none';
            
            // é‡æ–°è¿è¡Œå¤±è´¥çš„ä»»åŠ¡
            failedTasks.forEach((task, index) => {
                setTimeout(() => {
                    executeMethod(task.method, task.params || {});
                }, index * 1000); // æ¯ä¸ªä»»åŠ¡é—´éš”1ç§’
            });
        }
        
        // é‡æ–°è¿è¡Œå¤±è´¥çš„æ‰¹é‡ä»»åŠ¡
        function retryFailedBatchTasks() {
            const failedTasks = batchResults.filter(r => !r.success);
            if (failedTasks.length === 0) {
                alert('æ²¡æœ‰å¤±è´¥çš„ä»»åŠ¡éœ€è¦é‡æ–°è¿è¡Œ');
                return;
            }
            
            if (!confirm(`ç¡®å®šè¦é‡æ–°è¿è¡Œ ${failedTasks.length} ä¸ªå¤±è´¥çš„ä»»åŠ¡å—ï¼Ÿ`)) {
                return;
            }
            
            // æ¸…ç©ºå½“å‰ç»“æœ
            batchResults = [];
            document.getElementById('batchExportButtons').style.display = 'none';
            
            // é‡æ–°è¿è¡Œå¤±è´¥çš„ä»»åŠ¡
            const methodName = document.getElementById('batchMethodSelect').value;
            const paramsList = failedTasks.map(task => task.params || {});
            
            executeBatch(methodName, paramsList);
        }
        
        // é‡æ–°è¿è¡Œå¤±è´¥çš„å¤šæ–¹æ³•æ‰¹é‡ä»»åŠ¡
        function retryFailedMultiBatchTasks() {
            const failedTasks = multiBatchResults.filter(r => !r.success);
            if (failedTasks.length === 0) {
                alert('æ²¡æœ‰å¤±è´¥çš„ä»»åŠ¡éœ€è¦é‡æ–°è¿è¡Œ');
                return;
            }
            
            if (!confirm(`ç¡®å®šè¦é‡æ–°è¿è¡Œ ${failedTasks.length} ä¸ªå¤±è´¥çš„ä»»åŠ¡å—ï¼Ÿ`)) {
                return;
            }
            
            // æ¸…ç©ºå½“å‰ç»“æœ
            multiBatchResults = [];
            document.getElementById('multiBatchExportButtons').style.display = 'none';
            
            // é‡æ–°è¿è¡Œå¤±è´¥çš„ä»»åŠ¡
            const tasks = failedTasks.map(task => ({
                method: task.method,
                params: task.params || {}
            }));
            
            // ä½¿ç”¨é»˜è®¤é…ç½®é‡æ–°æ‰§è¡Œ
            const timeout = 30;
            const concurrency = 5;
            const intervalConfig = { type: 'fixed', value: 0 };
            const randomOrder = false;
            const groupByMethod = false;
            const executeBtn = document.getElementById('multiBatchExecuteBtn');
            const resultArea = document.getElementById('multiBatchResultArea');
            
            executeBtn.disabled = true;
            executeBtn.textContent = 'â³ é‡æ–°æ‰§è¡Œå¤±è´¥ä»»åŠ¡ä¸­...';
            resultArea.style.display = 'block';
            
            executeMultiBatchTasks(tasks, timeout, concurrency, intervalConfig, randomOrder, groupByMethod, executeBtn, resultArea);
        }
        
        // é¡µé¢åŠ è½½æ—¶è·å–æ•°æ®
        loadData();
        
        // æ¯5ç§’è‡ªåŠ¨åˆ·æ–°
        setInterval(loadData, 5000);
    </script>
</body>
</html>